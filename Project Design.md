# LFTP (c++) 实验设计
## 基本类 RdtSender(发送方) 和 RdtReciver(接收方)
### 第一步：实现 rdt3.0 和 流水线 rdt (GBN)
![](https://img-blog.csdn.net/20170725161404699)
1. 差错校验：这一步不需要实现，UDP 已提供。
2. 为每个包引入报文头部，并加入包序号, 不同于TCP的是，包序号为包的个数问不是当前开始的字节。`发送窗口`设置为 **20** 用于测试。
3. 超时间隔设置:
    * 初始值设置为 `5` 秒,(推荐初始值为 `1` 秒)。
    * 为报文头部添加 `sendTime`。在接收方发`送到响应报文时应当回传该值，发送方用该值进行如下计算:
        * `SampleRTT = clock() - sendTime`
        * `EstimatedRTT = 0.875 * EstimatedRTT + 0.125 * SampleRTT`
        * `DevRTT = 0.75 * DevRTT + 0.25 * abs(EstimatedRTT - SampleRTT)`
        * 将超时间隔设置为`MaxTimeLimit = EstimastedRTT + 4 * DevRTT`
4. 为发送方和接收方提供多线程支持，具体如下:
    * 发送方：
        | 线程功能 | 线程运行的函数名 | 在本步骤的作用 |
        | :---: | :---: | :---: |
        | 计时 | timer | 为超时重传设置标志 |
        | 发送文件 | rdt_send_file | 实现超时重传的动作(不与`rdt_send_pACKets`同时工作) |
        | 发送指定数量的数据包 | rdt_send_pACKets | 实现超时重传的动作(不与`rdt_send_file`同时工作) |
        | 接收响应的报文 | rdt_rcv | 判断是否期望的需要已经发送到接收方 |
    * 接收方：
        | 线程功能 | 线程运行的函数名 | 在本步骤的作用 |
        | :---: | :---: | :---: |
        | 接收文件 | rdt_rcv_file | 接收报文并响应报文(不与`rdt_rcv_pACKets`同时工作) |
        | 接收指定数量的数据包 | rdt_rcv_pACKets | 接收报文并响应文件(不与`rdt_rcv_file`同时工作) |
5. 按照 FSM 图实现发送方，接收方。
6. 使用 GBN 算法实现重传。
### 第二步：快速重传
1. 接收方引入新函数 `timer` 定时器。
2. 参考 `RIFC 5681` 实现接收方对报文的响应规则：
   * `RIFC 5681`对接收方产生ACK的建议:
        | 事件 | 接收方动作 |
        | :---: | :---: |
        | 具有所期望序号的按序报文段到达。所有在期望序号及以前的数据都已经被确认 | 延迟的ACK。对另一个按序报文段的到达最多等待500ms。如果下一个按序报文在这个时间间隔内没有到达，则发送一个ACK |
        | 具有所期望序号的按序报文段到达。另一个按序报文段等待ACK传输 | 立即发送累积 ACK,已确认两个按序报文段 |
        | 比期望序号大的失序报文段到达，检测出间隔 | 立即发送冗余 ACK, 指示下一个期待字节的序号(其为时间间隔低端的序号) |
        | 能部分或完全填充接收数据间隔的报文段到达 | 倘若该报文段起始于间隔的低端，则立即发送 ACK |
   * 本实验实现的接收方产生 ACK 动作:
        | 事件 | 接收方动作 |
        | :---: | :---: |
        | 具有所期望序号的按序报文段到达。所有在期望序号及以前的数据都已经被确认 | 产生`ACK` |
        | 具有所期望序号的按序报文段到达。缓存中可能具有下一个期待的报文段 | 产生一个`ACK`,该`ACK`确认最后一个报文段,该报文段可以来自缓存 |
        | 比期望序号大的失序报文段到达，检测出间隔 | 缓存,不产生`ACK` |
        | 比期望序号小的失序报文段到达，检测出间隔 | 无动作 |
        | 定时器到达时间限制 `500 ms` | 产生一个`ACK` |
3. 定时器刷新限制
   * 接收方
        | 事件 | 接收方动作 |
        | :---: | :---: |
        | 具有所期望序号的按序报文段到达。所有在期望序号及以前的数据都已经被确认 | 刷新定时器 |
        | 具有所期望序号的按序报文段到达。另一个按序报文段等待ACK传输 | 刷新定时器 |
        | 比期望序号大的失序报文段到达，检测出间隔 | 不刷新定时器 |
        | 比期望序号小的失序报文段到达，检测出间隔 | 不刷新定时器 |
        | 定时器到达时间限制 `500 ms` | 刷新定时器 |
        | 定时器连续`30`次到达时间限制 | 发送方离线,终止传输 |
   * 发送方
        | 事件 | 接收方动作 |
        | :---: | :---: |
        | 接收到的`ACK`所确认的报文序号大于`base` (GBN 中的 `base`) | 刷新定时器 |
        | 接收到的`ACK`所确认的报文序号不大于`base` | 冗余`ACK` |
        | 冗余`ACK`达到3个 | 报文丢失，重传，刷新定时器 |
        | 定时器刷新间隔超过`15s` | 发送方离线,终止传输 |
### 第三步: 流量控制

在包头中加入接收方的缓存窗口大小参数，每次接收报文时，用该值更新发送窗口。

### 第四步: 拥塞控制
![](https://upload-images.jianshu.io/upload_images/5663010-64b247aed9e57a95.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/698/format/webp)
1. 发送方添加函数`CongestionControl`。按照 FSM 实现该函数。
2. 发送窗口设置为 `cwnd` 和 `接收方缓存窗口大小` 的最小值。